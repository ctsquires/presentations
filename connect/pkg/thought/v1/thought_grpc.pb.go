// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: thought/v1/thought.proto

package thoughtv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ThoughtServiceClient is the client API for ThoughtService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ThoughtServiceClient interface {
	GetThought(ctx context.Context, in *GetThoughtRequest, opts ...grpc.CallOption) (*GetThoughtResponse, error)
	ReceiveThoughts(ctx context.Context, in *ReceiveThoughtsRequest, opts ...grpc.CallOption) (ThoughtService_ReceiveThoughtsClient, error)
	SendThoughts(ctx context.Context, opts ...grpc.CallOption) (ThoughtService_SendThoughtsClient, error)
	ConverseThoughts(ctx context.Context, opts ...grpc.CallOption) (ThoughtService_ConverseThoughtsClient, error)
}

type thoughtServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewThoughtServiceClient(cc grpc.ClientConnInterface) ThoughtServiceClient {
	return &thoughtServiceClient{cc}
}

func (c *thoughtServiceClient) GetThought(ctx context.Context, in *GetThoughtRequest, opts ...grpc.CallOption) (*GetThoughtResponse, error) {
	out := new(GetThoughtResponse)
	err := c.cc.Invoke(ctx, "/thought.v1.ThoughtService/GetThought", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *thoughtServiceClient) ReceiveThoughts(ctx context.Context, in *ReceiveThoughtsRequest, opts ...grpc.CallOption) (ThoughtService_ReceiveThoughtsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ThoughtService_ServiceDesc.Streams[0], "/thought.v1.ThoughtService/ReceiveThoughts", opts...)
	if err != nil {
		return nil, err
	}
	x := &thoughtServiceReceiveThoughtsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ThoughtService_ReceiveThoughtsClient interface {
	Recv() (*ReceiveThoughtsResponse, error)
	grpc.ClientStream
}

type thoughtServiceReceiveThoughtsClient struct {
	grpc.ClientStream
}

func (x *thoughtServiceReceiveThoughtsClient) Recv() (*ReceiveThoughtsResponse, error) {
	m := new(ReceiveThoughtsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *thoughtServiceClient) SendThoughts(ctx context.Context, opts ...grpc.CallOption) (ThoughtService_SendThoughtsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ThoughtService_ServiceDesc.Streams[1], "/thought.v1.ThoughtService/SendThoughts", opts...)
	if err != nil {
		return nil, err
	}
	x := &thoughtServiceSendThoughtsClient{stream}
	return x, nil
}

type ThoughtService_SendThoughtsClient interface {
	Send(*SendThoughtsRequest) error
	CloseAndRecv() (*SendThoughtsResponse, error)
	grpc.ClientStream
}

type thoughtServiceSendThoughtsClient struct {
	grpc.ClientStream
}

func (x *thoughtServiceSendThoughtsClient) Send(m *SendThoughtsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *thoughtServiceSendThoughtsClient) CloseAndRecv() (*SendThoughtsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SendThoughtsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *thoughtServiceClient) ConverseThoughts(ctx context.Context, opts ...grpc.CallOption) (ThoughtService_ConverseThoughtsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ThoughtService_ServiceDesc.Streams[2], "/thought.v1.ThoughtService/ConverseThoughts", opts...)
	if err != nil {
		return nil, err
	}
	x := &thoughtServiceConverseThoughtsClient{stream}
	return x, nil
}

type ThoughtService_ConverseThoughtsClient interface {
	Send(*ConverseThoughtsRequest) error
	Recv() (*ConverseThoughtsResponse, error)
	grpc.ClientStream
}

type thoughtServiceConverseThoughtsClient struct {
	grpc.ClientStream
}

func (x *thoughtServiceConverseThoughtsClient) Send(m *ConverseThoughtsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *thoughtServiceConverseThoughtsClient) Recv() (*ConverseThoughtsResponse, error) {
	m := new(ConverseThoughtsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ThoughtServiceServer is the server API for ThoughtService service.
// All implementations must embed UnimplementedThoughtServiceServer
// for forward compatibility
type ThoughtServiceServer interface {
	GetThought(context.Context, *GetThoughtRequest) (*GetThoughtResponse, error)
	ReceiveThoughts(*ReceiveThoughtsRequest, ThoughtService_ReceiveThoughtsServer) error
	SendThoughts(ThoughtService_SendThoughtsServer) error
	ConverseThoughts(ThoughtService_ConverseThoughtsServer) error
	mustEmbedUnimplementedThoughtServiceServer()
}

// UnimplementedThoughtServiceServer must be embedded to have forward compatible implementations.
type UnimplementedThoughtServiceServer struct {
}

func (UnimplementedThoughtServiceServer) GetThought(context.Context, *GetThoughtRequest) (*GetThoughtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetThought not implemented")
}
func (UnimplementedThoughtServiceServer) ReceiveThoughts(*ReceiveThoughtsRequest, ThoughtService_ReceiveThoughtsServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceiveThoughts not implemented")
}
func (UnimplementedThoughtServiceServer) SendThoughts(ThoughtService_SendThoughtsServer) error {
	return status.Errorf(codes.Unimplemented, "method SendThoughts not implemented")
}
func (UnimplementedThoughtServiceServer) ConverseThoughts(ThoughtService_ConverseThoughtsServer) error {
	return status.Errorf(codes.Unimplemented, "method ConverseThoughts not implemented")
}
func (UnimplementedThoughtServiceServer) mustEmbedUnimplementedThoughtServiceServer() {}

// UnsafeThoughtServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ThoughtServiceServer will
// result in compilation errors.
type UnsafeThoughtServiceServer interface {
	mustEmbedUnimplementedThoughtServiceServer()
}

func RegisterThoughtServiceServer(s grpc.ServiceRegistrar, srv ThoughtServiceServer) {
	s.RegisterService(&ThoughtService_ServiceDesc, srv)
}

func _ThoughtService_GetThought_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetThoughtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThoughtServiceServer).GetThought(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/thought.v1.ThoughtService/GetThought",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThoughtServiceServer).GetThought(ctx, req.(*GetThoughtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThoughtService_ReceiveThoughts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReceiveThoughtsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ThoughtServiceServer).ReceiveThoughts(m, &thoughtServiceReceiveThoughtsServer{stream})
}

type ThoughtService_ReceiveThoughtsServer interface {
	Send(*ReceiveThoughtsResponse) error
	grpc.ServerStream
}

type thoughtServiceReceiveThoughtsServer struct {
	grpc.ServerStream
}

func (x *thoughtServiceReceiveThoughtsServer) Send(m *ReceiveThoughtsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ThoughtService_SendThoughts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ThoughtServiceServer).SendThoughts(&thoughtServiceSendThoughtsServer{stream})
}

type ThoughtService_SendThoughtsServer interface {
	SendAndClose(*SendThoughtsResponse) error
	Recv() (*SendThoughtsRequest, error)
	grpc.ServerStream
}

type thoughtServiceSendThoughtsServer struct {
	grpc.ServerStream
}

func (x *thoughtServiceSendThoughtsServer) SendAndClose(m *SendThoughtsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *thoughtServiceSendThoughtsServer) Recv() (*SendThoughtsRequest, error) {
	m := new(SendThoughtsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ThoughtService_ConverseThoughts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ThoughtServiceServer).ConverseThoughts(&thoughtServiceConverseThoughtsServer{stream})
}

type ThoughtService_ConverseThoughtsServer interface {
	Send(*ConverseThoughtsResponse) error
	Recv() (*ConverseThoughtsRequest, error)
	grpc.ServerStream
}

type thoughtServiceConverseThoughtsServer struct {
	grpc.ServerStream
}

func (x *thoughtServiceConverseThoughtsServer) Send(m *ConverseThoughtsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *thoughtServiceConverseThoughtsServer) Recv() (*ConverseThoughtsRequest, error) {
	m := new(ConverseThoughtsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ThoughtService_ServiceDesc is the grpc.ServiceDesc for ThoughtService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ThoughtService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "thought.v1.ThoughtService",
	HandlerType: (*ThoughtServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetThought",
			Handler:    _ThoughtService_GetThought_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReceiveThoughts",
			Handler:       _ThoughtService_ReceiveThoughts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SendThoughts",
			Handler:       _ThoughtService_SendThoughts_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ConverseThoughts",
			Handler:       _ThoughtService_ConverseThoughts_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "thought/v1/thought.proto",
}
